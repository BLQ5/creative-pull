project_path: /web/_project.yaml
book_path: /web/updates/_book.yaml
description: Реагирование на прокрутку имеет решающее значение для взаимодействия пользователя с веб-сайтом на мобильном устройстве, однако слушатели событий колеса прокрутки мыши часто вызывают серьезные проблемы с производительностью прокрутки. Узнайте, как мы помогаем пользователям и разработчикам работать быстро по умолчанию.

{# wf_updated_on: 2019-09-14 #} {# wf_published_on: 2019-02-07 #} {# wf_tags:
interventions,chrome73 #} {# wf_featured_image:
/web/updates/images/generic/warning.png #} {# wf_featured_snippet: Реагирование
на прокрутку имеет решающее значение для взаимодействия пользователя с
веб-сайтом на мобильном устройстве, однако слушатели событий <code>колеса
прокрутки мыши</code> часто вызывают серьезные проблемы с производительностью
прокрутки. Узнайте, как мы помогаем пользователям и разработчикам работать
быстро по умолчанию. #} {# wf_blink_components: N/A #}

# Делаем прокрутку колеса мыши быстрой по умолчанию {: .page-title }

{% include "web/_shared/contributors/sahel.html" %}

Для повышения производительности прокрутки / масштабирования `колеса прокрутки`
разработчикам рекомендуется регистрировать {a1}прослушиватели событий{/a1}
`колеса прокрутки` и {code3}mousewheel{/code3} {a4}как пассивные{/a4} , передав
параметр `{passive: true}` в `addEventListener()` . Регистрация прослушивателей
событий в качестве пассивных говорит браузеру, что слушатели колеса не будут
вызывать {code7}preventDefault(){/code7} и браузер может безопасно выполнять
прокрутку и масштабирование, не блокируя слушателей.

Проблема заключается в том, что чаще всего слушатели событий колеса прокрутки
мыши концептуально пассивны (не вызывают `preventDefault()` ), но не указываются
явно как таковые, что требует от браузера ждать завершения обработки события JS,
прежде чем он начнет прокручивать / масштабировать, даже если ожидание не
обязательно. В Chrome 56 [мы исправили эту проблему для `touchstart` и
`touchmove`](/web/updates/2017/01/scrolling-intervention), и позднее это
изменение было принято как Safari, так и Firefox. Как вы можете видеть из
демонстрационного видео, которое мы сделали в то время, оставив поведение таким,
каким оно было, была заметна задержка в ответе прокрутки. Теперь в Chrome 73 мы
применили такое же вмешательство к событиям `wheel` и `mousewheel`.

<div class="video-wrapper">
<iframe class="devsite-embedded-youtube-video" data-video-id="65VMej8n23A"
data-autohide="1" data-showinfo="0" frameborder="0" allowfullscreen>
  </iframe>
</div>

## The Intervention

Цель этого изменения состоит в том, чтобы сократить время, необходимое для
обновления дисплея после того, как пользователь начинает прокручивать с помощью
колесика или сенсорной панели без необходимости изменения кода разработчиками.
Наши метрики показывают, что 75% слушателей событий `wheel` и `mousewheel`,
зарегистрированных в корневых целях (window, document или body), не задают
никаких значений для пассивной опции, и более 98% таких слушателей не вызывают
`preventDefault()`, В Chrome 73 мы изменяем слушатели `wheel` и `mousewheel`
зарегистрированные на корневых целях (window, document или body), на пассивные
по умолчанию. Это означает, что слушатель событий похож на:

```js
window.addEventListener("wheel", func);
```

становится эквивалентным:

```js
window.addEventListener("wheel", func, {passive: true});
```

И вызов `preventDefault()` внутри слушателя будет проигнорирован со следующим
предупреждением DevTools:

```
[Intervention] Unable to preventDefault inside passive event listener due
to target being treated as passive. See https://www.chromestatus.com/features/6662647093133312
```

## Поломка и руководство

В подавляющем большинстве случаев поломок не будет. Только в редких случаях
(менее 0,3% страниц в соответствии с нашими метриками) может произойти
непреднамеренная прокрутка/масштабирование из-за того, что `preventDefault()`
игнорируется внутри слушателей, которые по умолчанию считаются пассивными. Ваше
приложение может определить, может ли оно ударить это в дикой природе, проверив,
имел ли какой-либо эффект `preventDefault()` через свойство `defaultPrevented`.
Исправление для затронутых случаев относительно просто: передайте `{passive:
false}` в `addEventListener()` чтобы переопределить поведение по умолчанию и
сохранить слушатель событий как блокирующий.

## Обратная связь {: .hide-from-toc }

{% include "web/_shared/helpful.html" %}

<div class="clearfix"></div>

{% include "web/_shared/rss-widget-updates.html" %}
